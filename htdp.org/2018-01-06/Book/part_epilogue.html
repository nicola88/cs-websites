<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Epilogue: Moving On</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="shared.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">How to Design Programs, Second Edition</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="part_preface.html" class="tocviewlink" data-pltdoc="x">Preface</a></td></tr><tr><td align="right"></td><td><a href="part_prologue.html" class="tocviewlink" data-pltdoc="x">Prologue:<span class="mywbr"> &nbsp;</span> How to Program</a></td></tr><tr><td align="right">I&nbsp;</td><td><a href="part_one.html" class="tocviewlink" data-pltdoc="x">Fixed-<wbr></wbr>Size Data</a></td></tr><tr><td align="right"></td><td><a href="i1-2.html" class="tocviewlink" data-pltdoc="x">Intermezzo 1: Beginning Student Language</a></td></tr><tr><td align="right">II&nbsp;</td><td><a href="part_two.html" class="tocviewlink" data-pltdoc="x">Arbitrarily Large Data</a></td></tr><tr><td align="right"></td><td><a href="i2-3.html" class="tocviewlink" data-pltdoc="x">Intermezzo 2: Quote, Unquote</a></td></tr><tr><td align="right">III&nbsp;</td><td><a href="part_three.html" class="tocviewlink" data-pltdoc="x">Abstraction</a></td></tr><tr><td align="right"></td><td><a href="i3-4.html" class="tocviewlink" data-pltdoc="x">Intermezzo 3: Scope and Abstraction</a></td></tr><tr><td align="right">IV&nbsp;</td><td><a href="part_four.html" class="tocviewlink" data-pltdoc="x">Intertwined Data</a></td></tr><tr><td align="right"></td><td><a href="i4-5.html" class="tocviewlink" data-pltdoc="x">Intermezzo 4: The Nature of Numbers</a></td></tr><tr><td align="right">V&nbsp;</td><td><a href="part_five.html" class="tocviewlink" data-pltdoc="x">Generative Recursion</a></td></tr><tr><td align="right"></td><td><a href="i5-6.html" class="tocviewlink" data-pltdoc="x">Intermezzo 5: The Cost of Computation</a></td></tr><tr><td align="right">VI&nbsp;</td><td><a href="part_six.html" class="tocviewlink" data-pltdoc="x">Accumulators</a></td></tr><tr><td align="right"></td><td><a href="part_epilogue.html" class="tocviewselflink" data-pltdoc="x">Epilogue:<span class="mywbr"> &nbsp;</span> Moving On</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;">&bull;</td><td></td><td><a href="part_epilogue.html" class="tocviewselflink" data-pltdoc="x">Epilogue:<span class="mywbr"> &nbsp;</span> Moving On</a></td></tr></table></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="part_epilogue.html#%28part._computing%29" class="tocsubseclink" data-pltdoc="x">Computing</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="part_epilogue.html#%28part._programming%29" class="tocsubseclink" data-pltdoc="x">Program Design</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="part_epilogue.html#%28part._moving-on-devs%29" class="tocsubseclink" data-pltdoc="x">Onward, Developers and Computer Scientists</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="part_epilogue.html#%28part._moving-on-everyone%29" class="tocsubseclink" data-pltdoc="x">Onward, Accountants, Journalists, Surgeons, and Everyone Else</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">6.11.0.4</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="part_six.html" title="backward to &quot;VI Accumulators&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;How to Design Programs, Second Edition&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><h3><a name="(part._part~3aepilogue)"></a>Epilogue: Moving On</h3><a name="(part._chap~3apart~3aepilogue)"></a><p>You have reached the end of this introduction to computing and programming,
or program design, as we say here. While there is more to learn about both
subjects, this is a good point to stop, summarize, and look ahead.</p><h4><a name="(part._computing)"></a>Computing</h4><p>In elementary school, you learned to calculate with numbers. At first, you
 used numbers to count real things: three apples, five friends, twelve
 bagels. A bit later, you encountered addition, subtraction,
 multiplication, and even division; then came fractions. Eventually, you
 found out about variables and functions, which your teachers called
 <span style="font-weight: bold">algebra</span>. Variables represented numbers, and functions related
 numbers to numbers.</p><p>Because you used numbers throughout this process, you didn&rsquo;t think much of
 numbers as a means to represent information about the real world. Yes, you
 had started with three bears, five wolves, and twelve horses; but by high
 school, nobody reminded you of this relationship.</p><p>When you move from mathematical calculations to computing, the step from
 information to data and back becomes central.  Nowadays, programs process
 representations of music, videos, molecules, chemical compounds, business
 case studies, electrical diagrams, and blueprints. Fortunately, you don&rsquo;t
 need to encode all this information with numbers or, worse, just
 <span class="RktVal">0</span> and <span class="RktVal">1</span>; if you had to, life would be unimaginably
 tedious. Instead, computing generalizes arithmetic and algebra so that
 when you program, you can code&#8212;<wbr></wbr>and your programs can compute&#8212;<wbr></wbr>with
 strings, Booleans, characters, structures, lists, functions, and many more
 kinds of data.</p><p>Classes of data and their functions come with equational laws that explain
 their meaning, just like the laws for numbers and their functions. While
 these equational laws are as simple as &ldquo;<span class="RktPn">(</span><span class="RktSym">+</span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span> evaluates to
 <span class="RktVal">2</span>&rdquo; and &ldquo;<span class="RktPn">(</span><span class="RktSym">not</span><span class="stt"> </span><span class="RktVal">#true</span><span class="RktPn">)</span> equals <span class="RktVal">#false</span>,&rdquo; you can
 use them to predict the behavior of entire programs.  When you run a
 program, you actually just apply one of its many functions, an act that you
 can explain with the beta rule first mentioned in <a href="i1-2.html" data-pltdoc="x">Intermezzo 1: Beginning Student Language</a>. Once the
 variables are replaced with values, the laws of data take over until you
 have either only a value or another function application. But yes, that&rsquo;s
 all there is to computing.</p><h4><a name="(part._programming)"></a>Program Design</h4><p>A typical software development project requires the collaboration of many
 programmers, and the result consists of thousands of functions. Over the
 life span of such a project, programmers come and go. Hence, the design
 structure of programs is really a means of communication among programmers
 across time. When you approach code that someone else wrote some time ago,
 the program ought to express its <a name="(idx._(gentag._765))"></a>purpose and its relationships to other
 pieces&#8212;<wbr></wbr>because that other person might not be around anymore.</p><p>In such a dynamic context, programmers must create programs in a
 disciplined manner if they wish to work reasonable numbers of hours or
 produce high-quality products.  Following a systematic design method
 guarantees that the program organization is comprehensible. Others can
 then easily understand the pieces and the whole, and then fix bugs or add
 new pieces of functionality.</p><p>The <a name="(idx._(gentag._766))"></a>design process of this book is one of these methods, and you ought to
 follow it whenever you create programs you might care about. You start
 with an analysis of the world of information and a description of the data
 that represents the information. Then you make a plan, a work list of
 functions needed. If this list is large, you refine the process in an
 iterative manner. You start with a subset of functions that quickly yields
 a product with which a client can interact. As you observe these
 interactions, you will quickly figure out which elements of your work list
 to tackle next.</p><p>Designing a program, or only a function, requires a rigorous understanding
 of what it computes.  Unless you can describe the purpose of a piece of
 code with a concise statement, you cannot produce anything useful for
 future programmers. Make up, and work through, examples. Turn these
 examples into a <a name="(idx._(gentag._767))"></a>suite of tests. This test suite is even more important
 when it comes to future modifications of the program. Anyone who changes
 the code can rerun these tests and reconfirm that the program still works
 for the basic examples.</p><p>Eventually your program will also fail. Other programmers may use it in an
 unanticipated manner. Real-world users may find differences between
 expected and actual behavior. Because you have designed the code in a
 systematic manner, you will know what to do. You will formulate a failing
 test case for your program&rsquo;s main function. From this one test, you will
 derive a test case for each function that the main function
 mentions. Those functions that pass their new tests do not contribute to
 the failure. One of the others does; on occasion, several might collude to
 create a bug. If the broken function composes others, resume the
 test creation; otherwise you have found the source of the problem. You
 will know that you have fixed the problem when the program as a whole
 passes all its tests.</p><p>No matter how hard you work, a function or program isn&rsquo;t done the first
 time it passes the test suite. You must find time to inspect it for design
 flaws and repetitions of designs. If you find any design patterns, form
 new abstractions or use existing abstractions to eliminate these patterns.</p><p>If you respect these guidelines, you will produce solid software with
 reasonable effort. It will work because you understand why and how it
 works. Others who must modify or enhance your software will understand it
 quickly because the code communicates its process and its
 purpose. Working through this book got you started. Now you must practice,
 practice, practice. And you will have to learn a lot more about program
 design and computing than a first book can teach.</p><h4><a name="(part._moving-on-devs)"></a>Onward, Developers and Computer Scientists</h4><p>Right now, you might be wondering what to study next. The answer is both
more programming and more computing.</p><p>As a student of program design, your next task is to learn how the design
process applies in the setting of a full-fledged programming language. Some
of these languages are like the teaching languages, and the transition will be
easy. Others require a different mind-set because they offer means for
spelling out <a name="(idx._(gentag._768))"></a>data definitions (<span style="font-style: italic">classes</span> and <span style="font-style: italic">objects</span>) and
for formulating <a name="(idx._(gentag._769))"></a>signatures so that they are cross-checked before the
program is run (<span style="font-style: italic">types</span>).<span class="refelem"><span class="refcolumn"><span class="refcontent">Given your knowledge, it is
easy for you to learn <span style="font-style: italic">Racket</span>, the language behind the teaching
languages in this book. See
<a href="http://realmofracket.com/about.html">&ldquo;<span style="font-style: italic">Realm of Racket</span>&rdquo;</a> for
one possible introduction.</span></span></span>  In addition, you will also have to learn how
to scale the design process to the use and production of so-called
frameworks (&ldquo;stacks&rdquo;) and components.  Roughly speaking, frameworks
abstract pieces of functionality&#8212;<wbr></wbr>for example, graphical user interfaces,
database connections, and web connectivity&#8212;<wbr></wbr>that are common to many
software systems.  You need to learn to instantiate these abstractions, and
your programs will compose these instances to create coherent
systems. Similarly, learning to create new system components is also
inherently a part of scaling up your skills.</p><p>As a student of computing, you will also have to expand your understanding
of the computational process. This book has focused on the laws that
describe the process itself.  In order to function as a real software
engineer, you need to learn what the process costs, at both a theoretical
level and a practical one. Studying the concept of big-O in some more depth
is a first, small step in this direction; learning to measure and analyze a
program&rsquo;s performance is the real goal because you will need this skill as
a developer on a regular basis. Above and beyond these basic ideas, you
will also need knowledge about hardware, networking, layering of software,
and specialized algorithms in various disciplines.</p><h4><a name="(part._moving-on-everyone)"></a>Onward, Accountants, Journalists, Surgeons, and Everyone Else</h4><p>Some of you wanted to see what computing and programming are all about. You
now know that computing is merely a generalization of calculating, and you
may sense how useful program design is to you. Even if you never
develop programs again, you know what distinguishes a garage programmer
from a serious software developer. When you interact with developers as a
professional, you know that systematic design matters because it affects
your quality of life and the bottom line of your business.</p><p>In reality, though, you are likely to &ldquo;program&rdquo; again, on a regular basis;
you may just fail to see your activities in this light. Imagine a
journalist for a moment. His story starts with the collection of
information and data, laying it out, organizing it, and adding
anecdotes. If you squint, you&rsquo;ll see that this is only step one of the
<a name="(idx._(gentag._770))"></a>design process. Let&rsquo;s turn to a family doctor who, after checking up on
your symptoms, formulates a hypothesis of what might affect you. Do you see
step two? Or, think of a lawyer who illustrates the point of an
argument with a number of examples&#8212;<wbr></wbr>an instance of step three. Finally, a
civil engineer cross-checks the bridge as it is built to make sure it lives
up to the blueprint and the underlying static calculations. Cross-checking
is a form of testing&#8212;<wbr></wbr>step six of the process; it compares actual
measurements with expected values from the predictive calculations. Each of
these professionals develops a system to work effectively and efficiently;
and deep down, this system is likely to resemble the design process
employed in this book.</p><p>Now, once you accept that many activities are a form of programming, you
can transfer additional ideas from the design process to your own life. For
example, if you recognize patterns, you may take the little additional time
it takes to create an &ldquo;abstraction&rdquo;&#8212;<wbr></wbr>a single point of control&#8212;<wbr></wbr>to
simplify your future work. So, regardless of whether you become an
accountant or a doctor or something else, remember the design processes
wherever you go and whatever you do.</p><p><span style="font-weight: bold">Exercise</span> Write a short essay on how the <a name="(idx._(gentag._771))"></a>design process
may help you with your chosen profession. </p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="part_six.html" title="backward to &quot;VI Accumulators&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;How to Design Programs, Second Edition&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>